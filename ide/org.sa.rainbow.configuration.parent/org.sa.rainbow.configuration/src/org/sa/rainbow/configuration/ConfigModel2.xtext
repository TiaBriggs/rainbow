grammar org.sa.rainbow.configuration.ConfigModel hidden (WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//import "platform:/resource/org.sa.rainbow.configuration/model/ConfigModel.ecore"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
generate configModel "http://www.sa.org/rainbow/configuration/ConfigModel"

ConfigurationModel:
	'target' targetName=FQN
	imports+=Import*
	(
		(delcaredProperties+=DeclaredProperty)*
		(loggingProperties+=LoggingProperty)*
		(communicationProperties+=CommunicationProperty)*
		(deploymentProperties+=DeploymentProperty)*
		(directoryProperties+=DirectoryProperty)*
		(targetProperties+=TargetProperty)*
		(modelProperties+=Model)*
		(analysisProperties+=Analysis)*
		(managerProperties+=Manager)*
		(executorProperties+=Executor)*
		(effectorProperties+=EffectorManager)*
	) 
;

Setup returns PropertyContainer:
	(name='setup' '{' properties=RootComponent'}');
	
//Models returns PropertyContainer: (name='models' '{' properties=RootComponent '}');
//Analysis returns PropertyContainer: (name='analysis' '{' properties=RootComponent '}');
//Managers returns PropertyContainer: (name="managers" '{' properties=RootComponent '}');
//Executors returns PropertyContainer: (name="executors" '{' properties=RootComponent '}');
//Effectors returns PropertyContainer: (name="effector-managers" '{' properties=RootComponent '}');
//Systems returns PropertyContainer: (name="system" "properties" '{' properties=RootComponent '}')
//;

DeclaredProperty:
	'var' (type=[types::JvmType|FQN])? name=(STRING)('=' default=Value)?
;

LoggingProperty:
	'logging' name=STRING '=' value=Value 
;

CommunicationProperty:
	'comms' name=STRING '=' value=Value 
;

DeploymentProperty:
	'deployment' name=STRING '=' value=Value
;

DirectoryProperty:
	(name='gauge' | name='probe' | name='effector' | name='stitch')'path' '=' value=Value
;

TargetProperty:
	'target' name=STRING '=' value=Value
;

Model:
	'model' name=ID '=' properties=Component
;

Analysis:
	'analysis' name=ID '=' properties=Component
;

Manager:
	'planner' name=ID '=' properties=Component
;

Executor:
	'executor' name=ID '=' properties=Component
;

EffectorManager:
	'effector' 'manager' name=ID properties=Component
;


Import:
	'import' importedNamespace=ImportedFQN
;

ImportedFQN:
	FQN ('.*')?
;

RootComponent returns Component:
	{Component} 
	   assignment+=Assignment*
	
;

Component returns Component:
	{Component} '{'
	assignment+=Assignment*
	'}'
;

Assignment:
	name=FQN  '=' value=Value
;

Value:
	value=Component |
	value=StringLiteral |
	value=BooleanLiteral |
	value=IntegerLiteral |
	value=DoubleLiteral |
	value=Reference |
	value=PropertyRef |
	value=IPLiteral |
	value=LogLiteral
;

LogLiteral:
	value=LOGLEVEL
;

enum LOGLEVEL:
	OFF | FATAL | ERROR | WARN | INFO | DEBUG | TRACE | ALL
;

IPLiteral:
	value=IPValue
;

IPValue returns ecore::EString:
	INT '.' INT '.' INT '.' INT
;

DoubleLiteral:
	value=DoubleValue
;

DoubleValue returns ecore::EDouble:
	IntValue '.' INT
;

IntegerLiteral:
	value=IntValue
;

IntValue returns ecore::EInt:
	('-' | '+')? INT
;

BooleanLiteral:
	{BooleanLiteral}(isTrue?='true'|'false')
;

Reference:
	(referable=[types::JvmType|ID]) 
;
	
FQN:
	ID ('.' ID)*
;

StringLiteral:
	value=STRING
;

PropertyRef:
	referable=[Model|STRING]
;

PropertyReference:
	value=PROPERTY_REFERENCE
;

//StringLiteral hidden():
//	begin="'"
//	parts+=PlainString?
//	(parts+=PropertyReference parts+=PlainString)*
//	end="'"
//	|
//	begin='"'
//	parts+=PlainString?
//	(parts+=PropertyReference parts+=PlainString)*
//	end='"'
//;
//
terminal PROPERTY_REFERENCE:
	'${' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '}'
;

//PropertyReferenceImpl returns PropertyReference hidden(WS,ML_COMMENT,SL_COMMENT):
//	referable=[DeclaredProperty|FQN]
//;
//
//PlainString:
//	value=ConstantValue
//;
//
//// To identify other keywords or INT as allowed parts in a string,
//// we use a customized lexer with predicates. 
//// This allows us to use e.g. single quotes without escape sequences
//// in double quoted strings and vice versa.
//ConstantValue:
//  (WS|
//  ANY_OTHER|
//  ID|
//  INT |
//  "true" | 
//  "false" |
//  "target" | "setup" | "models" | "analysis" | "managers" | "executors" | "effector-managers" |
//  "system" | "properties" | "var" | "import" |
//  "." |
//  "\\'" | 
//  '\\"' | 
//  "\\${" | 
//  "\\\\")+;

terminal ID:
	('a'..'z' | 'A'..'Z') (('a'..'z' | 'A'..'Z') | '_' | '-' | '0'..'9')*
;

terminal INT returns ecore::EInt:
	('0'..'9')+
;

terminal STRING returns ecore::EString:
	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
;

terminal ML_COMMENT:
  '/*'->'*/';

terminal SL_COMMENT:
  '//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
  (' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
  .;



