grammar org.sa.rainbow.configuration.ConfigModel hidden (WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//import "platform:/resource/org.sa.rainbow.configuration/model/ConfigModel.ecore"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
generate configModel "http://www.sa.org/rainbow/configuration/ConfigModel"

ConfigurationModel:
	'target' targetName=FQN 
	imports+=Import*
	(delcaredProperties+=DeclaredProperty)*
	(
		
		(probeTypes+=ProbeType)*
		(probes+=Probe)*
	) 
	(
		(gaugeTypes+=GaugeType)*
		(gauges+=Gauge)*
		
	)
//	exports+=Export*
	export=Export?
;

ModelType:
	'model' 'type' name=ID ('->' superType=[ModelType])? '=' '{' properties=Component '}'
	('commands' '=' '{' (commands+=CommandSignature)+ '}') 'generate' filename=STRING
;

CommandSignature:
	'command'
;

Export:
	'export' references=References 'to' filename=STRING
;

References:
	{References} all?='*' |
	(refs+=[Ref|FQN]) (',' refs+=[Ref|FQN])*
;

Ref:
	DeclaredProperty | Probe | Gauge
;

DeclaredProperty:
	'def' (type=[types::JvmType|FQN])? name=FQN('=' default=Value)? 
;

ProbeType returns Probe:
	'probe' type?='type' name=ID '=' properties=Component
;

Probe returns Probe:
	'probe' name=ID ('->' superType=[Probe])? ('=' properties=Component)?
;

GaugeType returns Gauge:
	'gauge' type?='type' name=ID '=' body=GaugeTypeBody
;

Gauge returns Gauge:
	'gauge' name=ID ('->' superType=[Gauge])? /*('=' properties=Component)?*/ ('=' body=Component)?
;

GaugeTypeBody:
	'{'
	    'model' 'factory' (name=FQN)?'::' modeltype=ID '=' mcf=[types::JvmType|FQN]
	    (commands+=CommandReference)+
		(assignments+=Assignment)*
		
	'}'
;

CommandReference:
	'command' name=ID '=' (target=ID '.')? command=ID '(' (formal+=[types::JvmType|FQN] (',' formal+=[types::JvmType|FQN])*)? ')'
;

FormalParam:
	{FormalParam} 'int' | {FormalParam} 'boolean' | {FormalParam} 'double' | {FormalParam} 'String' | Reference //| {FormalParam} ID 
;

enum ImportType:
	CONFIG='configuration' |
	PROPS='properties' 
;


Import:
//	'import' importedNamespace=ImportedFQN
'import' type=ImportType importURI=STRING 
;

ImportedFQN:
	FQN ('.*')?
;

RootComponent returns Component:
	{Component} 
	   assignment+=Assignment*
	
;
Component returns Component:
	{Component} '{'
	assignment+=Assignment*
	'}'
;

Assignment:
	name=FQN  '=' value=Value
;

Value:
	value=Component |
	value=StringLiteral |
	value=BooleanLiteral |
	value=IntegerLiteral |
	value=DoubleLiteral |
	value=Reference |
	value=IPLiteral |
	value=LogLiteral |
	value=PropertyReference |
	value=ProbeReference
;

LogLiteral:
	value=LOGLEVEL
;

enum LOGLEVEL:
	OFF | FATAL | ERROR | WARN | INFO | DEBUG | TRACE | ALL
;

IPLiteral:
	value=IPValue
;

IPValue returns ecore::EString:
	INT '.' INT '.' INT '.' INT
;

DoubleLiteral:
	value=DoubleValue
;

DoubleValue returns ecore::EDouble:
	IntValue '.' INT
;

IntegerLiteral:
	value=IntValue
;

IntValue returns ecore::EInt:
	('-' | '+')? INT
;

BooleanLiteral:
	{BooleanLiteral}(isTrue?='true'|'false')
;

Reference:
	(referable=[types::JvmType|FQN]) 
;

PropertyReference:
	'${'(referable=[DeclaredProperty|FQN])'}'
;

ProbeReference:
	'probe' referable=[Probe|FQN]
;
	
FQN:
	ID ('.' ID)*
;

StringLiteral:
	value=STRING
;
//
//PropertyRef:
//	referable=[Model|STRING]
//;
//
//PropertyReference:
//	value=PROPERTY_REFERENCE
//;

//StringLiteral hidden():
//	begin="'"
//	parts+=PlainString?
//	(parts+=PropertyReference parts+=PlainString)*
//	end="'"
//	|
//	begin='"'
//	parts+=PlainString?
//	(parts+=PropertyReference parts+=PlainString)*
//	end='"'
//;
//
//PropertyReference hidden():
//  '${' PropertyReferenceImpl '}';
//
////terminal PROPERTY_REFERENCE:
////	'${' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '}'
////;
//
//PropertyReferenceImpl returns PropertyReference hidden(WS,ML_COMMENT,SL_COMMENT):
//	referable=[DeclaredProperty|FQN]
//;
//
//PlainString:
//	value=ConstantValue
//;
//
//// To identify other keywords or INT as allowed parts in a string,
//// we use a customized lexer with predicates. 
//// This allows us to use e.g. single quotes without escape sequences
//// in double quoted strings and vice versa.
//ConstantValue:
//  (WS|
//  ANY_OTHER|
//  ID|
//  INT |
//  "target" | "var" | "probe" | "type"
////  "true" | 
////  "false" |
////  "target" | "setup" | "models" | "analysis" | "managers" | "executors" | "effector-managers" |
////  "system" | "properties" | "var" | "import" |
//  "." |
//  "\\'" | 
//  '\\"' | 
//  "\\${" | 
//  "\\\\")+;

terminal ID:
	('^')?('a'..'z' | 'A'..'Z') (('a'..'z' | 'A'..'Z') | '_' | '-' | '0'..'9')*
;

terminal INT returns ecore::EInt:
	('0'..'9')+
;

terminal STRING returns ecore::EString:
	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
;

terminal ML_COMMENT:
  '/*'->'*/';

terminal SL_COMMENT:
  ('//' | '#') !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
  (' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
  .;



