/*
 * generated by Xtext 2.19.0
 */
package org.sa.rainbow.configuration.generator

import java.util.HashMap
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.sa.rainbow.configuration.configModel.Assignment
import org.sa.rainbow.configuration.configModel.BooleanLiteral
import org.sa.rainbow.configuration.configModel.Component
import org.sa.rainbow.configuration.configModel.ConfigurationModel
import org.sa.rainbow.configuration.configModel.DeclaredProperty
import org.sa.rainbow.configuration.configModel.DoubleLiteral
import org.sa.rainbow.configuration.configModel.Gauge
import org.sa.rainbow.configuration.configModel.IPLiteral
import org.sa.rainbow.configuration.configModel.IntegerLiteral
import org.sa.rainbow.configuration.configModel.LogLiteral
import org.sa.rainbow.configuration.configModel.Probe
import org.sa.rainbow.configuration.configModel.PropertyReference
import org.sa.rainbow.configuration.configModel.Reference
import org.sa.rainbow.configuration.configModel.StringLiteral
import org.sa.rainbow.configuration.configModel.Value

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ConfigModelGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as ConfigurationModel 
		var filename = model?.export.filename
		if (filename == null) filename=("generated-unnamed");
		if (model.probes !== null) {
			fsa.generateFile(filename, outputProbeSpec(model.probes, model.delcaredProperties))
		}
		if (model.gauges !== null) {
			fsa.generateFile(filename, outputGuageSpec(model.gauges, model.delcaredProperties))
		}
		if (filename.endsWith("properties") || (model.gauges == null && model.probes == null && model.delcaredProperties != null)) {
			var output = outputPropertiesSpec(model.delcaredProperties)
			output = "# Generated from RBW file so don't edit directly\n" + output
			fsa.generateFile(filename, output);
		}
		
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
	}
		
		def outputPropertiesSpec(EList<DeclaredProperty> vars) '''
		  «FOR v : vars»
		  «v.name» = «stringValue(v.^default,false)»
		  «ENDFOR»
		'''
		
		def outputGuageSpec(EList<Gauge> gauges, EList<DeclaredProperty> vars) '''
		vars:
		  «FOR v : vars»
		  «IF v.^default !== null»
		    «v.name»: «stringValue(v.^default, false)»
		  «ENDIF»
		  «ENDFOR»
		gauges:
		  «FOR gauge : gauges»
«««		    «outputGauge(gauge)»
		  «ENDFOR»
		  
		'''
		
		def outputProbeSpec(EList<Probe> probes, EList<DeclaredProperty> vars) '''
		vars:
		  «FOR v : vars»
		  «IF v.^default !== null»
		    «v.name» : «stringValue(v.^default, false)»
		  «ENDIF»
		  «ENDFOR»
		probes:
		  «FOR probe : probes »
		    «outputProbe(probe)»
		  «ENDFOR»
		'''
		
		def outputProbe(Probe probe) {
			val attsST = getAssignmentsMap(probe?.superType?.properties?.assignment)
			val atts = getAssignmentsMap(probe?.properties?.assignment)
			return '''
			«probe.name»:
			  «FOR entry : attsST.entrySet()»
			  «IF !atts.containsKey(entry.getKey())»
			    «IF entry.getKey() == "script"»
			      type: script
			      scriptInfo: «stringValue(entry.getValue().value, true, null)»
			    «ELSEIF entry.getKey() == "java"»
			      type: java
			      javaInfo: «stringValue(entry.getValue().value, true, null)»
			    «ELSE»
			      «entry.getKey()» : «stringValue(entry.getValue().value, true)»
			    «ENDIF»
			  «ENDIF»
			  «ENDFOR»
			  «FOR entry : atts.entrySet()»
			    «IF entry.getKey() == "script"»
			      type: script
			      scriptInfo: «stringValue(entry.getValue().value, true, attsST.get(entry.getKey())?.value)»
			    «ELSEIF entry.getKey() == "java"»
			      type: java
			      javaInfo: «stringValue(entry.getValue().value, true, attsST.get(entry.getKey())?.value)»
			    «ELSE»
			      «entry.getKey()» : «stringValue(entry.getValue().value, true, attsST.get(entry.getKey())?.value)»
			    «ENDIF»
			  «ENDFOR»
			'''
		}
		
		def getAssignmentsMap(EList<Assignment> assignments) {
			val map = new HashMap<String,Assignment> ()
			for (assignment : assignments) {
				map.put(assignment.name, assignment)
			}
			return map
		}
		
		def stringValue(Value value, boolean allowComponent, Value mergeComponentWith) {
			if (value.value instanceof Component && allowComponent) {
				var comp = value.value as Component
				val atts = getAssignmentsMap(comp.assignment)
				val attsST = getAssignmentsMap((mergeComponentWith.value as Component).assignment)
				return '''
				
				  «FOR entry : attsST.entrySet()»
				    «IF !atts.containsKey(entry.getKey())»
				      «entry.getKey()»: «stringValue(entry.getValue().value, true)»
				    «ENDIF»
				  «ENDFOR»
				  «FOR entry : atts.entrySet()»
				    «entry.getKey()»: «stringValue(entry.getValue().value, true)»
				  «ENDFOR»
				'''
			}
		}
		
		def stringValue(Value value, boolean allowComposite) {
			if (value.value instanceof StringLiteral) {
				var st = value.value as StringLiteral 
				return '''"«st.value»"'''
			}
			if (value.value instanceof BooleanLiteral) {
				var b = value.value as BooleanLiteral
				return '''«b.isTrue»'''
			}
			if (value.value instanceof IntegerLiteral) {
				var i = value.value as IntegerLiteral
				return '''«i.value»'''
			}
			if (value.value instanceof DoubleLiteral) {
				var d = value.value as DoubleLiteral
				return '''«d.value»'''
			}
			if (value.value instanceof Reference) {
				var r = value.value as Reference
				return '''«r.referable»'''
			}
			if (value.value instanceof IPLiteral) {
				var ip = value.value as IPLiteral
				return '''«ip.value»'''
			}
			if (value.value instanceof LogLiteral) {
				var ll = value.value as LogLiteral
				return '''«ll.value»'''
			}
			if (value.value instanceof PropertyReference) {
				var pr = value.value as PropertyReference
				return '''"${«pr.referable.name»}"'''
			}
			if (value.value instanceof Component && allowComposite) {
				return '''"Not implemented yet"'''
			}
		}
		
		
	
}
