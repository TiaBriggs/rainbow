/*
 * generated by Xtext 2.19.0
 */
package org.sa.rainbow.configuration.validation

import com.google.inject.Inject
import com.google.inject.name.Named
import java.util.HashMap
import java.util.Map
import java.util.Set
import java.util.regex.Pattern
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.common.types.access.IJvmTypeProvider
import org.eclipse.xtext.common.types.util.RawSuperTypes
import org.eclipse.xtext.validation.Check
import org.sa.rainbow.configuration.configModel.Assignment
import org.sa.rainbow.configuration.configModel.CommandReference
import org.sa.rainbow.configuration.configModel.ConfigModelPackage
import org.sa.rainbow.configuration.configModel.ConfigurationModel
import org.sa.rainbow.configuration.configModel.DeclaredProperty
import org.sa.rainbow.configuration.configModel.GaugeTypeBody
import org.sa.rainbow.configuration.configModel.Probe
import org.sa.rainbow.configuration.configModel.ProbeReference
import org.sa.rainbow.configuration.configModel.StringLiteral
import org.eclipse.xtext.common.types.util.Primitives

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ConfigModelValidator extends AbstractConfigModelValidator {

	public static val ONLY_EXTEND_PROBE_TYPES_MSG = "A probe can only extend a probe type"
	public static val ONLY_EXTEND_PROBE_TYPES = "invalidProbeType"

	public static val ALL_OFREQUIRED_PROBE_FIELDS = #{"alias", "location"};
	public static val ONE_OFRequired_PROBE_FIELDS = #{"script", "java"}

	@Check
	def checkOnlyProbeAsSupertype(Probe probe) {
		var st = probe.superType
		if (st !== null) {
			if (!st.type) {
				error(
					ONLY_EXTEND_PROBE_TYPES_MSG,
					ConfigModelPackage.Literals.PROBE__SUPER_TYPE,
					ONLY_EXTEND_PROBE_TYPES
				)
			}
		}

	}

	@Check
	def checkProbeContainsRequiredAttributes(Probe probe) {
		if (!probe.type) {
			checkAttributes(
				probe?.properties?.assignment,
				probe.superType?.properties?.assignment,
				ALL_OFREQUIRED_PROBE_FIELDS,
				ONE_OFRequired_PROBE_FIELDS,
				ConfigModelPackage.Literals.PROBE__PROPERTIES
			);
		}
	}

	@Check
	def checkProbeValue(ProbeReference v) {
		var p = v.eContainer
		while (p != null && !(p.eContainer instanceof Probe))
			p = p.eContainer
		if (p != null) {
			error(
				"A probe cannot refer to another probe",
				ConfigModelPackage.Literals.PROBE_REFERENCE__REFERABLE,
				"noProbeReferencesInProbe"
			)
		}
	}

	def checkAttributes(EList<Assignment> list, EList<Assignment> superlist, Set<String> requiredfields,
		Set<String> optionalFields, EReference reference) {
		for (String req : requiredfields) {
			var hasReq = list.exists [
				it.name == req
			];
			if (!hasReq && superlist !== null) {
				hasReq = superlist.exists [
					return it.name == req
				];
			}
			if (!hasReq) {
				warning(
					'''Expecting required field "«req»"''',
					reference,
					"missingRequiredProperty"
				)
			}
		}
		var hasOpt = false;
		for (String opt : optionalFields) {
			hasOpt = hasOpt || list.exists[return it.name == opt]
			if (superlist != null) {
				hasOpt = hasOpt || superlist.exists[return it.name == opt]
			}
		}
		if (!hasOpt) {
			var fields = optionalFields.map([return "\"" + it + "\""]).join(", ")
			warning(
				'''Expecting one of field «fields»''',
				reference,
				"missingRequiredProperty"
			)
		}
	}

	public Map<String, DeclaredProperty> m_declaredProperties = new HashMap();

	@Check
	def setupDeclaredVariables(ConfigurationModel m) {
		m_declaredProperties.clear();
		for (DeclaredProperty p : m?.delcaredProperties) {
			m_declaredProperties.put(p.name, p);
		}
//		for (Import ^import : m.imports) {
//			if (^import.type == ImportType.PROPS) {
//				var props = new Properties();
//				props.load(new FileInputStream(^import.importURI));
//				for (entry : props.entrySet) {
//					var dp = ConfigModelFactory.eINSTANCE.createDeclaredProperty();
//					dp.setName(entry.getKey() as String);
//					dp.setHide(true);
//					var v = ConfigModelFactory.eINSTANCE.createValue();
//					dp.setDefault(v);
//					var sl = ConfigModelFactory.eINSTANCE.createStringLiteral();
//					sl.value = entry.getValue() as String
//					v.value = sl;
//					m.delcaredProperties.add(dp);
//					m_declaredProperties.put(dp.name, dp);
//				}
//			} 
//		}
	}

	static final Pattern IN_STRING_REFERENCE_PATTERN = Pattern.compile("\\$\\{(.*)\\}")

	@Check
	def checkStringReferences(StringLiteral string) {
		var m = IN_STRING_REFERENCE_PATTERN.matcher(string.value);
		while (m.find()) {
			var ref = m.group(1)
			if (!m_declaredProperties.containsKey(ref)) {
				warning(
					'''Undefined property "«ref»"''',
					string,
					ConfigModelPackage.Literals.STRING_LITERAL__VALUE
				)
			}

		}
	}

	@Inject
	@Named("jvmtypes") private IJvmTypeProvider.Factory jvmTypeProviderFactory;
	@Inject
	private RawSuperTypes superTypeCollector;

	@Check
	def checkGaugeTypeModelFactory(GaugeTypeBody gaugeType) {
		var model = gaugeType.mcf
		if (model != null) {
			var jvmTypeProvider = jvmTypeProviderFactory.createTypeProvider(gaugeType.eResource.resourceSet);
			var I2I = jvmTypeProvider.findTypeByName("org.sa.rainbow.core.models.commands.ModelCommandFactory");
			var sts = superTypeCollector.collect(model);
			if (!sts.contains(I2I)) {
				error(
					'''«model.identifier» does not extend ModelCommandFactory''',
					ConfigModelPackage.Literals.GAUGE_TYPE_BODY__MCF,
					"wrongtype"
				)
			}

		}
	}

	@Check
	def checkCommandSignature(CommandReference cr) {
		if (cr.eContainer.eClass == ConfigModelPackage.Literals.GAUGE_TYPE_BODY) {
			var gaugeType = cr.eContainer as GaugeTypeBody
			var type = gaugeType.mcf as JvmDeclaredType
			var commandMethod = type.members.filter[it instanceof JvmOperation].filter [
				it.simpleName.equalsIgnoreCase(cr.command) || it.simpleName.equalsIgnoreCase(cr.command + "cmd")
			]

			if (commandMethod.empty) {
				error(
					'''"«cr.command»" is not a valid command in «type.identifier» ''',
					ConfigModelPackage.Literals.COMMAND_REFERENCE__COMMAND,
					"nocommand"
				)
			} else {
				var method = commandMethod.get(0) as JvmOperation
				if (method.parameters.size != cr.formal.size + (cr.target != null ? 1 : 0)) {
					if (cr.formal == null && method.parameters.size > 0) {
						
					} else {
						error(
							'''"«cr.command»" wrong number of parameters defined. Expecting «method.parameters.size-(cr.target!=null?1:0)» got «cr.formal.size»''',
							ConfigModelPackage.Literals.COMMAND_REFERENCE__FORMAL,
							"wrongparamnumbers"
						)
						return
					}
				}
					var first = true
					val prim = new Primitives()
					var i = 0
					for (param : method.parameters) {
						if (first && cr.target != null) {
							if (prim.isPrimitive(param.parameterType)) {
								warning('''«type.simpleName».«method.simpleName» may need a target''',
									ConfigModelPackage.Literals.COMMAND_REFERENCE__COMMAND,
									"mayNeedTarget"
								)
							}
						}
						else {
							if (param.parameterType.simpleName != cr.formal.get(i).simpleName) {
								error('''Parameter «i» expecing «param.parameterType.simpleName», received «cr.formal.get(i).simpleName».''',
									ConfigModelPackage.Literals.COMMAND_REFERENCE__FORMAL,
									"wrongType"
								)
							}
							i = i + 1
						}
						first = false
					}
			}
//			var tries=[cr.command, cr.command.toLowerCase, cr.commmand]
//			while (method == null)
		}
	}

//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					ConfigModelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
